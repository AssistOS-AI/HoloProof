<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HoloProof Document Viewer</title>
  <style>
    :root {
      --bg: #f3f5f7;
      --ink: #15222c;
      --muted: #4f5d69;
      --panel: #ffffff;
      --line: #d6dce2;
      --accent: #0f766e;
      --accent-soft: #e6fffb;
      --code-bg: #101a24;
      --code-text: #e8f0f7;
      --shadow: 0 14px 30px rgba(15, 23, 42, 0.09);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      font-family: "Avenir Next", "Trebuchet MS", "Gill Sans", sans-serif;
      line-height: 1.64;
      color: var(--ink);
      background:
        radial-gradient(1000px 680px at 8% -15%, #d9f7f2 0%, transparent 60%),
        radial-gradient(850px 480px at 95% 0%, #ecfdf5 0%, transparent 62%),
        var(--bg);
    }

    .container {
      width: min(1080px, 100% - 28px);
      margin: 0 auto;
    }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 8;
      backdrop-filter: blur(8px);
      background: rgba(243, 245, 247, 0.88);
      border-bottom: 1px solid var(--line);
    }

    .topbar-inner {
      width: min(1080px, 100% - 28px);
      margin: 0 auto;
      min-height: 66px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 0;
    }

    .back-link {
      text-decoration: none;
      color: #0b5560;
      font-weight: 700;
      border: 1px solid #9ed9d0;
      background: var(--accent-soft);
      border-radius: 999px;
      padding: 7px 11px;
      white-space: nowrap;
    }

    .back-link:hover {
      background: #d6fff8;
    }

    .doc-chip {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 6px 10px;
      background: #fff;
      color: #294455;
      font-size: 0.85rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: min(68ch, 74vw);
    }

    .hero {
      padding: 20px 0 10px;
    }

    .hero-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      background: linear-gradient(150deg, #0f766e 0%, #0f4f58 67%, #13334a 100%);
      color: #f8fffe;
      padding: 18px;
      box-shadow: var(--shadow);
    }

    .hero-card h1 {
      margin: 0 0 6px;
      font-size: clamp(1.26rem, 2.5vw, 1.7rem);
    }

    .hero-card p {
      margin: 0;
      color: #d8f8f3;
      font-size: 0.97rem;
    }

    main {
      flex: 1;
      padding-bottom: 20px;
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 260px;
      gap: 12px;
      align-items: start;
    }

    article {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: var(--panel);
      padding: 20px 18px;
      box-shadow: 0 8px 20px rgba(20, 33, 43, 0.06);
      overflow-wrap: anywhere;
    }

    aside {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: #f9fbfc;
      padding: 14px;
      color: #2d4454;
      position: sticky;
      top: 84px;
    }

    aside h2 {
      margin: 0 0 8px;
      font-size: 0.97rem;
      color: #113243;
    }

    aside p {
      margin: 0;
      font-size: 0.88rem;
      line-height: 1.5;
      color: #456071;
    }

    h1, h2, h3, h4, h5, h6 {
      line-height: 1.3;
      margin-top: 1.45em;
      margin-bottom: 0.58em;
      color: #0d2736;
    }

    h1 { margin-top: 0; }

    p { margin: 0.55em 0; color: #2e4453; }

    ul, ol { margin: 0.45em 0 0.9em 1.2em; padding: 0; }

    li { margin: 0.2em 0; color: #2e4453; }

    pre {
      background: var(--code-bg);
      color: var(--code-text);
      border: 1px solid #25364a;
      border-radius: 10px;
      padding: 13px;
      overflow-x: auto;
      margin: 0.8em 0;
    }

    code {
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: 0.9em;
      background: #e7edf2;
      padding: 0.1em 0.3em;
      border-radius: 4px;
      color: #1f3342;
    }

    pre code {
      background: transparent;
      color: inherit;
      padding: 0;
      border-radius: 0;
    }

    blockquote {
      margin: 0.8em 0;
      padding: 0.5em 0.85em;
      border-left: 4px solid var(--accent);
      background: #eefcf9;
      color: #2a4d58;
    }

    img {
      max-width: 100%;
      height: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      margin: 8px 0;
    }

    a { color: #0b5560; }

    .error {
      color: #8b1f1f;
      background: #fff1f2;
      border: 1px solid #fecdd3;
      border-radius: 10px;
      padding: 11px;
    }

    footer {
      border-top: 1px solid var(--line);
      background: #f9fbfc;
      padding: 18px 0 22px;
      margin-top: 8px;
    }

    footer p {
      margin: 7px 0;
      color: #3d4b56;
      font-size: 0.92rem;
    }

    @media (max-width: 930px) {
      .layout {
        grid-template-columns: 1fr;
      }

      aside {
        position: static;
      }
    }

    @media (max-width: 620px) {
      .topbar-inner {
        flex-wrap: wrap;
        align-items: flex-start;
        gap: 8px;
      }

      .doc-chip {
        max-width: 100%;
        width: 100%;
      }

      article {
        padding: 16px 14px;
      }
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="topbar-inner">
      <a class="back-link" href="index.html">Back to Hub</a>
      <div class="doc-chip" id="docTitle">Loading...</div>
    </div>
  </header>

  <section class="hero">
    <div class="container">
      <div class="hero-card">
        <h1>Design Specification Viewer</h1>
        <p>Markdown documents are rendered here for quick reading on desktop and mobile without leaving the docs workspace.</p>
      </div>
    </div>
  </section>

  <main>
    <div class="container layout">
      <article id="content">Loading document...</article>
      <aside>
        <h2>Reading Notes</h2>
        <p>This viewer renders local Markdown safely and keeps links between DS files navigable through the same loader page.</p>
      </aside>
    </div>
  </main>

  <footer>
    <div class="container">
      <p>Research conducted by Axiologic Research as part of the European research project Achilles.</p>
      <p>Commercialization partnership with LydiaRX Venture Studio.</p>
      <p>Disclaimer: this documentation was generated with AI assistance (LLMs) and may contain errors, exaggerations, or hallucinations. The public experiments are open sourceâ€”verify claims by examining the code, evaluation suites, and automated tests.</p>
    </div>
  </footer>

  <script>
    const contentEl = document.getElementById('content');
    const titleEl = document.getElementById('docTitle');

    function sanitizeDocPath(value) {
      if (!value || typeof value !== 'string') return null;
      const trimmed = value.trim();
      if (!trimmed) return null;
      if (!trimmed.endsWith('.md')) return null;
      if (trimmed.startsWith('/') || trimmed.includes('://') || trimmed.includes('..')) return null;
      return trimmed;
    }

    function normalizePath(path) {
      const parts = [];
      for (const part of path.split('/')) {
        if (!part || part === '.') continue;
        if (part === '..') {
          if (parts.length) parts.pop();
          continue;
        }
        parts.push(part);
      }
      return parts.join('/');
    }

    function escapeHtml(str) {
      return str
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function resolveRelativeUrl(rawUrl, docDir) {
      const trimmed = (rawUrl || '').trim();
      if (!trimmed) return '#';
      if (/^(https?:|mailto:|#|\/)/i.test(trimmed)) return trimmed;
      return normalizePath(docDir + trimmed);
    }

    function toLoaderLink(rawUrl, docDir) {
      const resolved = resolveRelativeUrl(rawUrl, docDir);
      if (resolved.toLowerCase().endsWith('.md')) {
        return 'loader.html?doc=' + encodeURIComponent(resolved);
      }
      return resolved;
    }

    function formatInline(raw, docDir) {
      const codeParts = [];
      let text = raw.replace(/`([^`]+)`/g, (_, code) => {
        const idx = codeParts.push(escapeHtml(code)) - 1;
        return `@@CSPAN${idx}@@`;
      });

      text = escapeHtml(text);

      text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, label, href) => {
        const safeHref = toLoaderLink(href, docDir).replaceAll('"', '%22');
        return `<a href="${safeHref}">${label}</a>`;
      });

      text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');

      text = text.replace(/@@CSPAN(\d+)@@/g, (_, idx) => `<code>${codeParts[Number(idx)] || ''}</code>`);
      return text;
    }

    function markdownToHtml(markdown, docDir) {
      const codeBlocks = [];
      let source = markdown.replace(/\r\n?/g, '\n');

      source = source.replace(/```([a-zA-Z0-9_-]*)\n([\s\S]*?)```/g, (_, lang, code) => {
        const languageClass = lang ? ` class="language-${escapeHtml(lang)}"` : '';
        const rendered = `<pre><code${languageClass}>${escapeHtml(code)}</code></pre>`;
        const idx = codeBlocks.push(rendered) - 1;
        return `@@CODE${idx}@@`;
      });

      const lines = source.split('\n');
      let html = '';
      let inUl = false;
      let inOl = false;

      const closeLists = () => {
        if (inUl) { html += '</ul>'; inUl = false; }
        if (inOl) { html += '</ol>'; inOl = false; }
      };

      for (const line of lines) {
        const trimmed = line.trim();

        if (!trimmed) {
          closeLists();
          continue;
        }

        const codeOnly = trimmed.match(/^@@CODE(\d+)@@$/);
        if (codeOnly) {
          closeLists();
          html += codeBlocks[Number(codeOnly[1])] || '';
          continue;
        }

        const heading = line.match(/^(#{1,6})\s+(.*)$/);
        if (heading) {
          closeLists();
          const level = heading[1].length;
          html += `<h${level}>${formatInline(heading[2], docDir)}</h${level}>`;
          continue;
        }

        if (/^(---|\*\*\*)$/.test(trimmed)) {
          closeLists();
          html += '<hr />';
          continue;
        }

        const image = trimmed.match(/^!\[([^\]]*)\]\(([^)]+)\)$/);
        if (image) {
          closeLists();
          const alt = escapeHtml(image[1]);
          const src = resolveRelativeUrl(image[2], docDir).replaceAll('"', '%22');
          html += `<p><img src="${src}" alt="${alt}" /></p>`;
          continue;
        }

        const unordered = line.match(/^\s*[-*]\s+(.*)$/);
        if (unordered) {
          if (!inUl) {
            closeLists();
            html += '<ul>';
            inUl = true;
          }
          html += `<li>${formatInline(unordered[1], docDir)}</li>`;
          continue;
        }

        const ordered = line.match(/^\s*\d+\.\s+(.*)$/);
        if (ordered) {
          if (!inOl) {
            closeLists();
            html += '<ol>';
            inOl = true;
          }
          html += `<li>${formatInline(ordered[1], docDir)}</li>`;
          continue;
        }

        const blockquote = line.match(/^>\s?(.*)$/);
        if (blockquote) {
          closeLists();
          html += `<blockquote>${formatInline(blockquote[1], docDir)}</blockquote>`;
          continue;
        }

        closeLists();
        html += `<p>${formatInline(trimmed, docDir)}</p>`;
      }

      closeLists();
      return html;
    }

    async function run() {
      const params = new URLSearchParams(window.location.search);
      const requested = params.get('doc') || 'specs/DS001-Vision.md';
      const docPath = sanitizeDocPath(requested);

      if (!docPath) {
        titleEl.textContent = 'Invalid document path';
        contentEl.innerHTML = '<p class="error">Invalid `doc` parameter. Use a safe relative .md path, for example `specs/DS001-Vision.md`.</p>';
        return;
      }

      titleEl.textContent = docPath;
      const slash = docPath.lastIndexOf('/');
      const docDir = slash >= 0 ? docPath.slice(0, slash + 1) : '';

      try {
        const response = await fetch(docPath, { cache: 'no-cache' });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const markdown = await response.text();
        contentEl.innerHTML = markdownToHtml(markdown, docDir);
        document.title = `HoloProof - ${docPath}`;
      } catch (error) {
        contentEl.innerHTML = `<p class="error">Could not load <code>${escapeHtml(docPath)}</code>: ${escapeHtml(error.message)}</p>`;
      }
    }

    run();
  </script>
</body>
</html>
