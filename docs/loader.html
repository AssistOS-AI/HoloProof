<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HoloProof Markdown Loader</title>
  <style>
    :root {
      --bg: #f1f5f9;
      --panel: #ffffff;
      --text: #0f172a;
      --muted: #475569;
      --line: #cbd5e1;
      --accent: #0c4a6e;
      --code-bg: #0b1220;
      --code-text: #e2e8f0;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Arial, sans-serif;
      background: radial-gradient(circle at top left, #e2e8f0 0%, #f8fafc 55%);
      color: var(--text);
    }
    .topbar {
      position: sticky;
      top: 0;
      z-index: 5;
      background: rgba(255, 255, 255, 0.92);
      border-bottom: 1px solid var(--line);
      backdrop-filter: blur(6px);
    }
    .topbar-inner {
      max-width: 980px;
      margin: 0 auto;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
    }
    .doc-title {
      font-size: 0.95rem;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 70vw;
    }
    .topbar a {
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
    }
    .container {
      max-width: 980px;
      margin: 20px auto 36px;
      padding: 0 14px;
    }
    article {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
      line-height: 1.65;
    }
    h1, h2, h3, h4, h5, h6 {
      line-height: 1.3;
      margin-top: 1.5em;
      margin-bottom: 0.55em;
    }
    h1 { margin-top: 0; }
    p { margin: 0.55em 0; }
    ul, ol { margin: 0.55em 0 0.85em 1.2em; }
    li { margin: 0.2em 0; }
    pre {
      background: var(--code-bg);
      color: var(--code-text);
      border-radius: 10px;
      padding: 14px;
      overflow-x: auto;
      border: 1px solid #1f2937;
    }
    code {
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
      font-size: 0.93em;
      background: #e2e8f0;
      padding: 0.12em 0.35em;
      border-radius: 4px;
    }
    pre code {
      background: transparent;
      padding: 0;
      border-radius: 0;
      color: inherit;
    }
    blockquote {
      margin: 0.8em 0;
      padding: 0.45em 0.9em;
      border-left: 4px solid var(--accent);
      background: #f0f9ff;
    }
    a { color: #0369a1; }
    img {
      max-width: 100%;
      height: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      margin: 8px 0;
    }
    .error {
      color: #991b1b;
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: 10px;
      padding: 12px;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="topbar-inner">
      <a href="index.html">Back to Specifications</a>
      <div class="doc-title" id="docTitle">Loading...</div>
    </div>
  </header>

  <main class="container">
    <article id="content">Loading document...</article>
  </main>

  <script>
    const contentEl = document.getElementById('content');
    const titleEl = document.getElementById('docTitle');

    function sanitizeDocPath(value) {
      if (!value || typeof value !== 'string') return null;
      const trimmed = value.trim();
      if (!trimmed) return null;
      if (!trimmed.endsWith('.md')) return null;
      if (trimmed.startsWith('/') || trimmed.includes('://') || trimmed.includes('..')) return null;
      return trimmed;
    }

    function normalizePath(path) {
      const parts = [];
      for (const part of path.split('/')) {
        if (!part || part === '.') continue;
        if (part === '..') {
          if (parts.length) parts.pop();
          continue;
        }
        parts.push(part);
      }
      return parts.join('/');
    }

    function escapeHtml(str) {
      return str
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function resolveRelativeUrl(rawUrl, docDir) {
      const trimmed = (rawUrl || '').trim();
      if (!trimmed) return '#';
      if (/^(https?:|mailto:|#|\/)/i.test(trimmed)) return trimmed;
      return normalizePath(docDir + trimmed);
    }

    function toLoaderLink(rawUrl, docDir) {
      const resolved = resolveRelativeUrl(rawUrl, docDir);
      if (resolved.toLowerCase().endsWith('.md')) {
        return 'loader.html?doc=' + encodeURIComponent(resolved);
      }
      return resolved;
    }

    function formatInline(raw, docDir) {
      const codeParts = [];
      let text = raw.replace(/`([^`]+)`/g, (_, code) => {
        const idx = codeParts.push(escapeHtml(code)) - 1;
        return `@@CSPAN${idx}@@`;
      });

      text = escapeHtml(text);

      text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, label, href) => {
        const safeHref = toLoaderLink(href, docDir).replaceAll('"', '%22');
        return `<a href="${safeHref}">${label}</a>`;
      });

      text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');

      text = text.replace(/@@CSPAN(\d+)@@/g, (_, idx) => `<code>${codeParts[Number(idx)] || ''}</code>`);
      return text;
    }

    function markdownToHtml(markdown, docDir) {
      const codeBlocks = [];
      let source = markdown.replace(/\r\n?/g, '\n');

      source = source.replace(/```([a-zA-Z0-9_-]*)\n([\s\S]*?)```/g, (_, lang, code) => {
        const languageClass = lang ? ` class="language-${escapeHtml(lang)}"` : '';
        const rendered = `<pre><code${languageClass}>${escapeHtml(code)}</code></pre>`;
        const idx = codeBlocks.push(rendered) - 1;
        return `@@CODE${idx}@@`;
      });

      const lines = source.split('\n');
      let html = '';
      let inUl = false;
      let inOl = false;

      const closeLists = () => {
        if (inUl) { html += '</ul>'; inUl = false; }
        if (inOl) { html += '</ol>'; inOl = false; }
      };

      for (const line of lines) {
        const trimmed = line.trim();

        if (!trimmed) {
          closeLists();
          continue;
        }

        const codeOnly = trimmed.match(/^@@CODE(\d+)@@$/);
        if (codeOnly) {
          closeLists();
          html += codeBlocks[Number(codeOnly[1])] || '';
          continue;
        }

        const heading = line.match(/^(#{1,6})\s+(.*)$/);
        if (heading) {
          closeLists();
          const level = heading[1].length;
          html += `<h${level}>${formatInline(heading[2], docDir)}</h${level}>`;
          continue;
        }

        if (/^(---|\*\*\*)$/.test(trimmed)) {
          closeLists();
          html += '<hr />';
          continue;
        }

        const image = trimmed.match(/^!\[([^\]]*)\]\(([^)]+)\)$/);
        if (image) {
          closeLists();
          const alt = escapeHtml(image[1]);
          const src = resolveRelativeUrl(image[2], docDir).replaceAll('"', '%22');
          html += `<p><img src="${src}" alt="${alt}" /></p>`;
          continue;
        }

        const unordered = line.match(/^\s*[-*]\s+(.*)$/);
        if (unordered) {
          if (!inUl) {
            closeLists();
            html += '<ul>';
            inUl = true;
          }
          html += `<li>${formatInline(unordered[1], docDir)}</li>`;
          continue;
        }

        const ordered = line.match(/^\s*\d+\.\s+(.*)$/);
        if (ordered) {
          if (!inOl) {
            closeLists();
            html += '<ol>';
            inOl = true;
          }
          html += `<li>${formatInline(ordered[1], docDir)}</li>`;
          continue;
        }

        const blockquote = line.match(/^>\s?(.*)$/);
        if (blockquote) {
          closeLists();
          html += `<blockquote>${formatInline(blockquote[1], docDir)}</blockquote>`;
          continue;
        }

        closeLists();
        html += `<p>${formatInline(trimmed, docDir)}</p>`;
      }

      closeLists();
      return html;
    }

    async function run() {
      const params = new URLSearchParams(window.location.search);
      const requested = params.get('doc') || 'specs/DS001-Vision.md';
      const docPath = sanitizeDocPath(requested);

      if (!docPath) {
        titleEl.textContent = 'Invalid document path';
        contentEl.innerHTML = '<p class="error">Invalid `doc` parameter. Use a safe relative .md path, for example `specs/DS001-Vision.md`.</p>';
        return;
      }

      titleEl.textContent = docPath;
      const slash = docPath.lastIndexOf('/');
      const docDir = slash >= 0 ? docPath.slice(0, slash + 1) : '';

      try {
        const response = await fetch(docPath, { cache: 'no-cache' });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const markdown = await response.text();
        contentEl.innerHTML = markdownToHtml(markdown, docDir);
        document.title = `HoloProof - ${docPath}`;
      } catch (error) {
        contentEl.innerHTML = `<p class="error">Could not load <code>${escapeHtml(docPath)}</code>: ${escapeHtml(error.message)}</p>`;
      }
    }

    run();
  </script>
</body>
</html>
